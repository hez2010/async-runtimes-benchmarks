<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>How Much Memory Do You Need in 2024 to Run 1 Million Concurrent Tasks&quest; - Take 2</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

/* From extension marp-team.marp-vscode */
#__marp-vscode {
  all: revert;
}

/* Override VS Code default CSS rules reverting to initial
   https://github.com/microsoft/vscode/blob/master/src/vs/workbench/contrib/webview/browser/pre/main.js#L53 */
body.marp-vscode {
  padding: 0;
}

body.marp-vscode img {
  max-width: unset;
  max-height: unset;
}

body.marp-vscode a,
body.marp-vscode a:hover,
body.marp-vscode code {
  color: unset;
}

body.marp-vscode blockquote {
  background: unset;
  border-color: unset;
}

@media screen {
  body.marp-vscode {
    overflow-y: scroll;
  }

  #__marp-vscode [data-marp-vscode-slide-wrapper] {
    margin: 20px;
  }

  #__marp-vscode svg[data-marpit-svg] {
    box-shadow: 0 5px 10px rgb(0 0 0 / 25%);
    display: block;
    margin: 0;
  }

  /* Based on https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
  #code-csp-warning {
    background-color: #444;
    box-shadow: 1px 1px 1px rgb(0 0 0 / 25%);
    color: white;
    cursor: pointer;
    font-family: sans-serif;
    font-size: 12px;
    line-height: 22px;
    margin: 16px;
    padding: 6px;
    position: fixed;
    right: 0;
    text-align: center;
    top: 0;
    word-wrap: break-word;
  }

  #code-csp-warning:hover {
    text-decoration: none;
    background-color: #007acc;
    box-shadow: 2px 2px 2px rgb(0 0 0 / 25%);
  }
}

@media print {
  body.marp-vscode #code-csp-warning {
    display: none;
  }
}

</style>
            
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h1 id="how-much-memory-do-you-need-in-2024-to-run-1-million-concurrent-tasks---take-2">How Much Memory Do You Need in 2024 to Run 1 Million Concurrent Tasks? - Take 2</h1>
<p>Did you still remember <a href="https://pkolaczk.github.io/memory-consumption-of-async/">the memory consumption comparison</a> between asynchronous programming across popular languages in 2023?</p>
<p>Now at the end of 2024, I wonder how things changed in the span of one year, with the latest version of languages.</p>
<p>So I did the benchmark again in <a href="/take1.html">How Much Memory Do You Need in 2024 to Run 1 Million Concurrent Tasks?</a></p>
<p>Then some folks pointed out that the code for some languages were non-optimal, so after taking changes from the community, I ran the benchmark again.</p>
<p>Now let's see the result.</p>
<h2 id="benchmark">Benchmark</h2>
<p>The program to benchmark is the same with the one in the last year:</p>
<blockquote>
<p>Let's launch N concurrent tasks, where each task waits for 10 seconds and then the program exists after all tasks finish. The number of tasks is controlled by the command line argument.</p>
</blockquote>
<p>This time, let's focus on coroutine instead of multiple threads.</p>
<p>All benchmark code can be accessed at <a href="https://github.com/hez2010/async-runtimes-benchmarks-2024">async-runtimes-benchmarks-2024</a>.</p>
<p>What is a coroutine?</p>
<blockquote>
<p>Coroutines are computer program components that allow execution to be suspended and resumed, generalizing subroutines for cooperative multitasking. Coroutines are well-suited for implementing familiar program components such as cooperative tasks, exceptions, event loops, iterators, infinite lists and pipes.</p>
</blockquote>
<h3 id="rust">Rust</h3>
<p>I created 3 programs in Rust. One uses <code>tokio</code>:</p>
<pre><code class="language-rust"><span class="hljs-keyword">use</span> std::env;
<span class="hljs-keyword">use</span> tokio::{spawn, time::{sleep, Duration}};

<span class="hljs-meta">#[tokio::main]</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">num_tasks</span> = env::<span class="hljs-title function_ invoke__">args</span>().<span class="hljs-title function_ invoke__">skip</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">parse</span>().<span class="hljs-title function_ invoke__">unwrap</span>();

    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">tasks</span> = Vec::<span class="hljs-title function_ invoke__">with_capacity</span>(num_tasks);
    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..num_tasks {
        tasks.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">10</span>))));
    }
    <span class="hljs-keyword">for</span> <span class="hljs-variable">task</span> <span class="hljs-keyword">in</span> tasks {
        task.<span class="hljs-keyword">await</span>.<span class="hljs-title function_ invoke__">unwrap</span>();
    }
}
</code></pre>
<p>One uses <code>async_std</code>:</p>
<pre><code class="language-rust"><span class="hljs-keyword">use</span> std::env;
<span class="hljs-keyword">use</span> async_std::task;
<span class="hljs-keyword">use</span> std::time::Duration;

<span class="hljs-meta">#[async_std::main]</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">num_tasks</span> = env::<span class="hljs-title function_ invoke__">args</span>().<span class="hljs-title function_ invoke__">skip</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">parse</span>().<span class="hljs-title function_ invoke__">unwrap</span>();

    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">tasks</span> = Vec::<span class="hljs-title function_ invoke__">with_capacity</span>(num_tasks);
    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..num_tasks {
        tasks.<span class="hljs-title function_ invoke__">push</span>(task::<span class="hljs-title function_ invoke__">spawn</span>(task::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">10</span>))));
    }

    <span class="hljs-keyword">for</span> <span class="hljs-variable">task</span> <span class="hljs-keyword">in</span> tasks {
        task.<span class="hljs-keyword">await</span>;
    }
}
</code></pre>
<p>And one uses <code>tokio</code> but uses <code>futures::future::join_all</code> to track all tasks instead of <code>spawn</code> each task separately:</p>
<pre><code class="language-rust"><span class="hljs-keyword">use</span> std::env;
<span class="hljs-keyword">use</span> std::time::Duration;

<span class="hljs-meta">#[tokio::main]</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">num_tasks</span> = env::<span class="hljs-title function_ invoke__">args</span>().<span class="hljs-title function_ invoke__">skip</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">parse</span>().<span class="hljs-title function_ invoke__">unwrap</span>();

    futures::future::<span class="hljs-title function_ invoke__">join_all</span>((<span class="hljs-number">0</span>..num_tasks).<span class="hljs-title function_ invoke__">map</span>(|_| tokio::time::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">10</span>))))
        .<span class="hljs-keyword">await</span>;
}
</code></pre>
<p>Both <code>tokio</code> and <code>async_std</code> are popular async runtime commonly used in Rust.</p>
<h3 id="c">C#</h3>
<p>C#, similar to Rust, has first-class support for async/await:</p>
<pre><code class="language-csharp"><span class="hljs-built_in">int</span> numTasks = <span class="hljs-built_in">int</span>.Parse(args[<span class="hljs-number">0</span>]);

List&lt;Task&gt; tasks = <span class="hljs-keyword">new</span> List&lt;Task&gt;(numTasks);

<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; numTasks; i++)
{
    tasks.Add(Task.Delay(TimeSpan.FromSeconds(<span class="hljs-number">10</span>)));
}

<span class="hljs-keyword">await</span> Task.WhenAll(tasks);
</code></pre>
<p>.NET also offers NativeAOT compilation since .NET 7, which compiles the code to the final binary directly so that it no longer needs a VM to run managed code. So we added the benchmark for NativeAOT as well.</p>
<h3 id="nodejs">NodeJS</h3>
<p>So does NodeJS:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;util&#x27;</span>);
<span class="hljs-keyword">const</span> delay = util.<span class="hljs-title function_">promisify</span>(<span class="hljs-built_in">setTimeout</span>);

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">runTasks</span>(<span class="hljs-params">numTasks</span>) {
  <span class="hljs-keyword">const</span> tasks = [];

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numTasks; i++) {
    tasks.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">delay</span>(<span class="hljs-number">10000</span>));
  }

  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(tasks);
}

<span class="hljs-keyword">const</span> numTasks = <span class="hljs-built_in">parseInt</span>(process.<span class="hljs-property">argv</span>[<span class="hljs-number">2</span>]);
<span class="hljs-title function_">runTasks</span>(numTasks);
</code></pre>
<h3 id="python">Python</h3>
<p>And Python, too:</p>
<pre><code class="language-python"><span class="hljs-keyword">import</span> asyncio
<span class="hljs-keyword">import</span> sys

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">num_tasks</span>):
    tasks = []

    <span class="hljs-keyword">for</span> task_id <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_tasks):
        tasks.append(asyncio.sleep(<span class="hljs-number">10</span>))

    <span class="hljs-keyword">await</span> asyncio.gather(*tasks)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:
    num_tasks = <span class="hljs-built_in">int</span>(sys.argv[<span class="hljs-number">1</span>])
    asyncio.run(main(num_tasks))
</code></pre>
<h3 id="go">Go</h3>
<p>In Go, goroutines are the building block for concurrency. We don’t await them separately, but we use a <code>WaitGroup</code> instead:</p>
<pre><code class="language-go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">&quot;fmt&quot;</span>
	<span class="hljs-string">&quot;os&quot;</span>
	<span class="hljs-string">&quot;strconv&quot;</span>
	<span class="hljs-string">&quot;sync&quot;</span>
	<span class="hljs-string">&quot;time&quot;</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	numRoutines := <span class="hljs-number">100000</span>
	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(os.Args) &gt; <span class="hljs-number">1</span> {
		n, err := strconv.Atoi(os.Args[<span class="hljs-number">1</span>])
		<span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> {
			numRoutines = n
		}
	}

	<span class="hljs-keyword">var</span> wg sync.WaitGroup
	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; numRoutines; i++ {
		wg.Add(<span class="hljs-number">1</span>)
		<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
			time.Sleep(<span class="hljs-number">10</span> * time.Second)
			wg.Done()
		}()
	}
	wg.Wait()
}
</code></pre>
<h3 id="java">Java</h3>
<p>Java offers virtual threads since JDK 21, which are a similar concept to goroutines:</p>
<pre><code class="language-java"><span class="hljs-keyword">import</span> java.time.Duration;
<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VirtualThreads</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException {
	    <span class="hljs-type">int</span> <span class="hljs-variable">numTasks</span> <span class="hljs-operator">=</span> Integer.parseInt(args[<span class="hljs-number">0</span>]);
        List&lt;Thread&gt; threads = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(numTasks);

        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numTasks; i++) {
            <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.startVirtualThread(() -&gt; {
                <span class="hljs-keyword">try</span> {
                    Thread.sleep(Duration.ofSeconds(<span class="hljs-number">10</span>));
                } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                    <span class="hljs-comment">// Handle exception</span>
                }
            });
            threads.add(thread);
        }

        <span class="hljs-keyword">for</span> (Thread thread : threads) {
            thread.join();
        }
    }
}
</code></pre>
<p>While there's a new variant of JVM called GraalVM. GraalVM also offers native image, which is a similar concept to NativeAOT in .NET. So we added the benchmark for GraalVM as well.</p>
<h2 id="test-environment">Test Environment</h2>
<ul>
<li>Hardware: 13th Gen Intel(R) Core(TM) i7-13700K</li>
<li>OS: Debian GNU/Linux 12 (bookworm)</li>
<li>Rust: 1.82.0</li>
<li>.NET: 9.0.100</li>
<li>Go: 1.23.3</li>
<li>Java: openjdk 23.0.1 build 23.0.1+11-39</li>
<li>Java (GraalVM): java 23.0.1 build 23.0.1+11-jvmci-b01</li>
<li>NodeJS: v23.2.0</li>
<li>Python: 3.13.0</li>
</ul>
<p>All programs were launched using the release mode if available, and support for internationalization and globalization was disabled as we did't have libicu in our test environment.</p>
<h2 id="results">Results</h2>
<script src="https://cdn.jsdelivr.net/npm/chart.js">

</script>
<h3 id="minimum-footprint">Minimum Footprint</h3>
<p>Let's start from something small, because some runtimes require some memory for themselves, let's first launch only one task.</p>
<div style="height:40vh; width:80vw">
  <canvas id="cvs-0">
  </canvas>
</div>
<script>
    const ctx0 = document.getElementById('cvs-0');
    new Chart(ctx0, {
        type: 'bar',
        data: {
            labels: ['Rust (tokio)', 'Rust (async_std)', 'Rust (futures)', 'C#', 'C# (NativeAOT)', 'Go', 'Java (OpenJDK)', 'Java (GraalVM)', 'Java (GraalVM native-image)', 'NodeJS', 'Python'],
            datasets: [
                { label: 'Memory (MB)', data: [4.71875, 5.1484375, 3.03515625, 24.359375, 3.58984375, 3.5546875, 46.91015625, 112.421875, 8.265625, 41.9296875, 19.515625] },
                { label: 'CPU (%)', data: [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0] },
                { label: 'Time (Sec)', data: [10, 10, 10, 10.01, 10, 10, 10.03, 10.11, 10, 10.05, 10.09] },
            ]
        },
        options: { indexAxis: 'y' }
    });
</script>
<p><strong>Note: You can click the legend label on the top to hide a specific legend.</strong></p>
<p>We can see that Rust, C# (NativeAOT), and Go achieved similar results, as they were compiled statically to native binaries and needed very little memory. Java (GraalVM native-image) also did a great job but cost a bit more than the other statically compiled ones. The other programs running on managed platforms or through interpreters consume more memory.</p>
<p>Rust (futures) seems to have the smallest footprint in this case. While Go and C# (NativeAOT) seem to have the similar minimal footprint.</p>
<p>Python, which is running on an interpreter, also shows great result.</p>
<p>Java with GraalVM is a bit surprising, as it cost far more memory than Java with OpenJDK, but I guess this can be tuned with some settings.</p>
<h3 id="10k-tasks">10K Tasks</h3>
<div style="height:40vh; width:80vw">
  <canvas id="cvs-1">
  </canvas>
</div>
<script>
    const ctx1 = document.getElementById('cvs-1');
    new Chart(ctx1, {
        type: 'bar',
        data: {
            labels: ['Rust (tokio)', 'Rust (async_std)', 'Rust (futures)', 'C#', 'C# (NativeAOT)', 'Go', 'Java (OpenJDK)', 'Java (GraalVM)', 'Java (GraalVM native-image)', 'NodeJS', 'Python'],
            datasets: [
                { label: 'Memory (MB)', data: [9.03515625, 8.1015625, 4.78125, 28.1171875, 7.55859375, 34.29296875, 108.37109375, 181.8359375, 22.828125, 64.7890625, 33.34765625] },
                { label: 'CPU (%)', data: [0, 0, 0, 0, 0, 0, 11, 6, 1, 0, 1] },
                { label: 'Time (Sec)', data: [10, 10, 10, 10.02, 10, 10.01, 10.1, 10.08, 10.03, 10.02, 10.1] },
            ]
        },
        options: { indexAxis: 'y' }
    });
</script>
<p>A few surprises here! The three Rust benchmarks, C# (NativeAOT) achieved very promising results: they both used very little memory (less than 10MB), which didn't grow too much compared to minimal footprint results, even though there were 10K tasks running behind the scenes! C# (NativeAOT) followed closely behind, using only ~10MB of memory. We need more tasks to put more pressure on them!</p>
<p>The memory consumption grew dramatically in Go. Goroutines are supposed to be very lightweight, but they actually consumed far more RAM than Rust required. In this case, virtual threads in Java (GraalVM native image) seem to be more lightweight than Goroutines in Go. To my surprise, both Go and Java (GraalVM native image), which were compiled to native binaries statically, cost similar RAM with the C# one running on a VM!</p>
<h3 id="100k-tasks">100K Tasks</h3>
<div style="height:40vh; width:80vw">
  <canvas id="cvs-2">
  </canvas>
</div>
<script>
    const ctx2 = document.getElementById('cvs-2');
    new Chart(ctx2, {
        type: 'bar',
        data: {
            labels: ['Rust (tokio)', 'Rust (async_std)', 'Rust (futures)', 'C#', 'C# (NativeAOT)', 'Go', 'Java (OpenJDK)', 'Java (GraalVM)', 'Java (GraalVM native-image)', 'NodeJS', 'Python'],
            datasets: [
                { label: 'Memory (MB)', data: [46.234375, 53.24609375, 22.7578125, 50.05078125, 30.02734375, 262.67578125, 196.96875, 419.01171875, 100.83984375, 125.06640625, 146.46875] },
                { label: 'CPU (%)', data: [1, 1, 0, 2, 2, 5, 70, 54, 14, 1, 9] },
                { label: 'Time (Sec)', data: [10.04, 10.03, 10.02, 10.07, 10, 10.09, 10.61, 10.25, 10.32, 10.06, 10.71] },
            ]
        },
        options: { indexAxis: 'y' }
    });
</script>
<p>After we increased the number of tasks to 100K, the memory consumption of all the languages started to grow significantly.</p>
<p>Both Rust and C# did a really good job in this case. Rust continues to lead the benchmark, and C# follows closely. Really impressive!</p>
<p>At this point, the Go program has been beaten not only by Rust but also by Java (except the one running on GraalVM), C#, and NodeJS. But worth to note that Java costs significantly more CPU to complete the benchmark.</p>
<h3 id="1-million-tasks">1 Million Tasks</h3>
<p>Let's go extreme now.</p>
<div style="height:40vh; width:80vw">
  <canvas id="cvs-3">
  </canvas>
</div>
<script>
    const ctx3 = document.getElementById('cvs-3');
    new Chart(ctx3, {
        type: 'bar',
        data: {
            labels: ['Rust (tokio)', 'Rust (async_std)', 'Rust (futures)', 'C#', 'C# (NativeAOT)', 'Go', 'Java (OpenJDK)', 'Java (GraalVM)', 'Java (GraalVM native-image)', 'NodeJS', 'Python'],
            datasets: [
                { label: 'Memory (MB)', data: [439.08984375, 502.25, 207.37890625, 218.38671875, 196.59375, 2585.5859375, 1095.1875, 1546.76171875, 1057.32421875, 563.88671875, 1275.71875] },
                { label: 'CPU (%)', data: [17, 19, 7, 21, 27, 28, 452, 475, 117, 13, 67] },
                { label: 'Time (Sec)', data: [10.41, 10.35, 10.3, 10.5, 10.58, 10.83, 15.98, 15.6, 13.41, 10.51, 19.36] },
            ]
        },
        options: { indexAxis: 'y' }
    });
</script>
<p>Finally, Rust (futures) and C# show very promising result; either is very competitive and has really become a monster.</p>
<p>And it's worth to note that Rust consistently cost the least CPU for running all the tasks.</p>
<p>NodeJS, which runs on a VM, also shows great result in this case: although it costs more RAM than C#, it requires less CPU to complete the benchmark, which is even less than some of the Rust benchmarks.</p>
<p>While both Java and Python start to be not able to complete the benchmark in 10 seconds, and Java costs significant more CPU than other languages.</p>
<h2 id="final-word">Final Word</h2>
<p>As we have observed, a high number of concurrent tasks can consume a significant amount of memory, even if they do not perform complex operations. Different language runtimes have varying trade-offs, with some being lightweight and efficient for a small number of tasks but scaling poorly with hundreds of thousands of tasks.</p>
<p>Many things have changed since last year. With the benchmark results on the latest compilers and runtimes, we see a huge improvement in .NET, and .NET with NativeAOT is really competitive.</p>
<p>Rust continues to be memory saving as expected, and achieved similar result with C# (NativeAOT).</p>
<p>NodeJS shows impressive result in term of CPU usage.</p>
<p>Python faced performance issue and was not able to complete the benchmark in time in the 1M case.</p>
<p>Both Java Virtual Thread and Goroutine take similar approach on concurrency, while others are using async/await, so let's exclude other languages and only focus on these two: the native image of Java built with GraalVM did a great job in terms of memory efficiency, but it failed to finished the benchmark in 10 seconds in the 1M case; while Goroutine is able to complete all the tasks in time, but it costs much more RAM than Java in the 1M case.</p>

            
            <script async type="text/javascript">
/* From extension marp-team.marp-vscode */
(()=>{var U=Object.defineProperty;var d=($,E)=>U($,"name",{value:E,configurable:!0});(()=>{var $={676:(w,b,g)=>{w.exports=g(185)},185:(w,b)=>{"use strict";var g;g={value:!0};const x={h1:{proto:()=>HTMLHeadingElement,attrs:{role:"heading","aria-level":"1"},style:"display: block; font-size: 2em; margin-block-start: 0.67em; margin-block-end: 0.67em; margin-inline-start: 0px; margin-inline-end: 0px; font-weight: bold;"},h2:{proto:()=>HTMLHeadingElement,attrs:{role:"heading","aria-level":"2"},style:"display: block; font-size: 1.5em; margin-block-start: 0.83em; margin-block-end: 0.83em; margin-inline-start: 0px; margin-inline-end: 0px; font-weight: bold;"},h3:{proto:()=>HTMLHeadingElement,attrs:{role:"heading","aria-level":"3"},style:"display: block; font-size: 1.17em; margin-block-start: 1em; margin-block-end: 1em; margin-inline-start: 0px; margin-inline-end: 0px; font-weight: bold;"},h4:{proto:()=>HTMLHeadingElement,attrs:{role:"heading","aria-level":"4"},style:"display: block; margin-block-start: 1.33em; margin-block-end: 1.33em; margin-inline-start: 0px; margin-inline-end: 0px; font-weight: bold;"},h5:{proto:()=>HTMLHeadingElement,attrs:{role:"heading","aria-level":"5"},style:"display: block; font-size: 0.83em; margin-block-start: 1.67em; margin-block-end: 1.67em; margin-inline-start: 0px; margin-inline-end: 0px; font-weight: bold;"},h6:{proto:()=>HTMLHeadingElement,attrs:{role:"heading","aria-level":"6"},style:"display: block; font-size: 0.67em; margin-block-start: 2.33em; margin-block-end: 2.33em; margin-inline-start: 0px; margin-inline-end: 0px; font-weight: bold;"},span:{proto:()=>HTMLSpanElement},pre:{proto:()=>HTMLElement,style:"display: block; font-family: monospace; white-space: pre; margin: 1em 0; --marp-auto-scaling-white-space: pre;"}},k="data-marp-auto-scaling-wrapper",u="data-marp-auto-scaling-svg",c="data-marp-auto-scaling-container",T=class T extends HTMLElement{constructor(){super(),this.svgPreserveAspectRatio="xMinYMid meet";const s=d(i=>([n])=>{const{width:e,height:t}=n.contentRect;this[i]={width:e,height:t},this.updateSVGRect()},"t");this.attachShadow({mode:"open"}),this.containerObserver=new ResizeObserver(s("containerSize")),this.wrapperObserver=new ResizeObserver((...i)=>{s("wrapperSize")(...i),this.flushSvgDisplay()})}static get observedAttributes(){return["data-downscale-only"]}connectedCallback(){var s,i,n,e,t;this.shadowRoot.innerHTML=`
<style>
  svg[${u}] { display: block; width: 100%; height: auto; vertical-align: top; }
  span[${c}] { display: table; white-space: var(--marp-auto-scaling-white-space, nowrap); width: max-content; }
</style>
<div ${k}>
  <svg part="svg" ${u}>
    <foreignObject><span ${c}><slot></slot></span></foreignObject>
  </svg>
</div>
    `.split(/\n\s*/).join(""),this.wrapper=(s=this.shadowRoot.querySelector(`div[${k}]`))!==null&&s!==void 0?s:void 0;const o=this.svg;this.svg=(n=(i=this.wrapper)===null||i===void 0?void 0:i.querySelector(`svg[${u}]`))!==null&&n!==void 0?n:void 0,this.svg!==o&&(this.svgComputedStyle=this.svg?window.getComputedStyle(this.svg):void 0),this.container=(t=(e=this.svg)===null||e===void 0?void 0:e.querySelector(`span[${c}]`))!==null&&t!==void 0?t:void 0,this.observe()}disconnectedCallback(){this.svg=void 0,this.svgComputedStyle=void 0,this.wrapper=void 0,this.container=void 0,this.observe()}attributeChangedCallback(){this.observe()}flushSvgDisplay(){const{svg:s}=this;s&&(s.style.display="inline",requestAnimationFrame(()=>{s.style.display=""}))}observe(){this.containerObserver.disconnect(),this.wrapperObserver.disconnect(),this.wrapper&&this.wrapperObserver.observe(this.wrapper),this.container&&this.containerObserver.observe(this.container),this.svgComputedStyle&&this.observeSVGStyle(this.svgComputedStyle)}observeSVGStyle(s){const i=d(()=>{const n=(()=>{const e=s.getPropertyValue("--preserve-aspect-ratio");return e?e.trim():`x${(({textAlign:t,direction:o})=>{if(t.endsWith("left"))return"Min";if(t.endsWith("right"))return"Max";if(t==="start"||t==="end"){let a=o==="rtl";return t==="end"&&(a=!a),a?"Max":"Min"}return"Mid"})(s)}YMid meet`})();n!==this.svgPreserveAspectRatio&&(this.svgPreserveAspectRatio=n,this.updateSVGRect()),s===this.svgComputedStyle&&requestAnimationFrame(i)},"e");i()}updateSVGRect(){var s,i,n,e,t,o,a;let p=Math.ceil((i=(s=this.containerSize)===null||s===void 0?void 0:s.width)!==null&&i!==void 0?i:0);const h=Math.ceil((e=(n=this.containerSize)===null||n===void 0?void 0:n.height)!==null&&e!==void 0?e:0);this.dataset.downscaleOnly!==void 0&&(p=Math.max(p,(o=(t=this.wrapperSize)===null||t===void 0?void 0:t.width)!==null&&o!==void 0?o:0));const f=(a=this.svg)===null||a===void 0?void 0:a.querySelector(":scope > foreignObject");if(f?.setAttribute("width",`${p}`),f?.setAttribute("height",`${h}`),this.svg&&(this.svg.setAttribute("viewBox",`0 0 ${p} ${h}`),this.svg.setAttribute("preserveAspectRatio",this.svgPreserveAspectRatio),this.svg.style.height=p<=0||h<=0?"0":""),this.container){const _=this.svgPreserveAspectRatio.toLowerCase();this.container.style.marginLeft=_.startsWith("xmid")||_.startsWith("xmax")?"auto":"0",this.container.style.marginRight=_.startsWith("xmi")?"auto":"0"}}};d(T,"s");let r=T;const m=d((l,{attrs:s={},style:i})=>class extends l{constructor(...n){super(...n);for(const[e,t]of Object.entries(s))this.hasAttribute(e)||this.setAttribute(e,t);this.attachShadow({mode:"open"})}static get observedAttributes(){return["data-auto-scaling"]}connectedCallback(){this._update()}attributeChangedCallback(){this._update()}_update(){const n=i?`<style>:host { ${i} }</style>`:"";let e="<slot></slot>";const{autoScaling:t}=this.dataset;t!==void 0&&(e=`<marp-auto-scaling exportparts="svg:auto-scaling" ${t==="downscale-only"?"data-downscale-only":""}>${e}</marp-auto-scaling>`),this.shadowRoot.innerHTML=n+e}},"o");let v;const j=Symbol();let C;const z="marpitSVGPolyfill:setZoomFactor,",A=Symbol(),D=Symbol(),W=d(()=>{const l=navigator.vendor==="Apple Computer, Inc.",s=l?[B]:[],i={then:n=>(l?(async()=>{if(C===void 0){const e=document.createElement("canvas");e.width=10,e.height=10;const t=e.getContext("2d"),o=new Image(10,10),a=new Promise(p=>{o.addEventListener("load",()=>p())});o.crossOrigin="anonymous",o.src="data:image/svg+xml;charset=utf8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2210%22%20height%3D%2210%22%20viewBox%3D%220%200%201%201%22%3E%3CforeignObject%20width%3D%221%22%20height%3D%221%22%20requiredExtensions%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxhtml%22%3E%3Cdiv%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxhtml%22%20style%3D%22width%3A%201px%3B%20height%3A%201px%3B%20background%3A%20red%3B%20position%3A%20relative%22%3E%3C%2Fdiv%3E%3C%2FforeignObject%3E%3C%2Fsvg%3E",await a,t.drawImage(o,0,0),C=t.getImageData(5,5,1,1).data[3]<128}return C})().then(e=>{n?.(e?[B]:[])}):n?.([]),i)};return Object.assign(s,i)},"h");let H,O;function B(l){const s=typeof l=="object"&&l.target||document,i=typeof l=="object"?l.zoom:l;window[D]||(Object.defineProperty(window,D,{configurable:!0,value:!0}),document.body.style.zoom=1.0001,document.body.offsetHeight,document.body.style.zoom=1,window.addEventListener("message",({data:e,origin:t})=>{if(t===window.origin)try{if(e&&typeof e=="string"&&e.startsWith(z)){const[,o]=e.split(","),a=Number.parseFloat(o);Number.isNaN(a)||(O=a)}}catch(o){console.error(o)}}));let n=!1;Array.from(s.querySelectorAll("svg[data-marpit-svg]"),e=>{var t,o,a,p;e.style.transform||(e.style.transform="translateZ(0)");const h=i||O||e.currentScale||1;H!==h&&(H=h,n=h);const f=e.getBoundingClientRect(),{length:_}=e.children;for(let F=0;F<_;F+=1){const S=e.children[F];if(S.getScreenCTM){const y=S.getScreenCTM();if(y){const I=(o=(t=S.x)===null||t===void 0?void 0:t.baseVal.value)!==null&&o!==void 0?o:0,Z=(p=(a=S.y)===null||a===void 0?void 0:a.baseVal.value)!==null&&p!==void 0?p:0,Y=S.children.length;for(let R=0;R<Y;R+=1){const N=S.children[R];if(N.tagName==="SECTION"){const{style:q}=N;q.transformOrigin||(q.transformOrigin=`${-I}px ${-Z}px`),q.transform=`scale(${h}) matrix(${y.a}, ${y.b}, ${y.c}, ${y.d}, ${y.e-f.left}, ${y.f-f.top}) translateZ(0.0001px)`;break}}}}}}),n!==!1&&Array.from(s.querySelectorAll("iframe"),({contentWindow:e})=>{e?.postMessage(`${z}${n}`,window.origin==="null"?"*":window.origin)})}d(B,"u");function P({once:l=!1,target:s=document}={}){const i=function(n=document){if(n[A])return n[A];let e=!0;const t=d(()=>{e=!1,delete n[A]},"i");Object.defineProperty(n,A,{configurable:!0,value:t});let o=[],a=!1;(async()=>{try{o=await W()}finally{a=!0}})();const p=d(()=>{for(const h of o)h({target:n});a&&o.length===0||e&&window.requestAnimationFrame(p)},"o");return p(),t}(s);return l?(i(),()=>{}):i}d(P,"v"),H=1,O=void 0;const G=P,M=Symbol(),L=d((l=document)=>{if(typeof window>"u")throw new Error("Marp Core's browser script is valid only in browser context.");if(((e=document)=>{const t=window[j];t||customElements.define("marp-auto-scaling",r);for(const o of Object.keys(x)){const a=`marp-${o}`,p=x[o].proto();v!=null||(v=!!document.createElement("div",{is:"marp-auto-scaling"}).outerHTML.startsWith("<div is")),v&&p!==HTMLElement?t||customElements.define(a,m(p,{style:x[o].style}),{extends:o}):(t||customElements.define(a,m(HTMLElement,x[o])),e.querySelectorAll(`${o}[is="${a}"]`).forEach(h=>{h.outerHTML=h.outerHTML.replace(new RegExp(`^<${o}`,"i"),`<${a}`).replace(new RegExp(`</${o}>$`,"i"),`</${a}>`)}))}window[j]=!0})(l),l[M])return l[M];const s=P({target:l}),i=d(()=>{s(),delete l[M]},"n"),n=Object.assign(i,{cleanup:i,update:()=>L(l)});return Object.defineProperty(l,M,{configurable:!0,value:n}),n},"y");b.browser=L,g=L,g=G}},E={};function V(w){var b=E[w];if(b!==void 0)return b.exports;var g=E[w]={exports:{}};return $[w](g,g.exports,V),g.exports}d(V,"__webpack_require__");var J={};(()=>{"use strict";var w=V(676);function b(){let u,c;const r=d(()=>{const m=document.getElementById("__marp-vscode"),v=!!m;u!==v?(document.body.classList.toggle("marp-vscode",v),v?c=(0,w.browser)():(c?.cleanup(),c=void 0),u=v):v&&c?.update(),u?(m&&g(m),x()):k()},"updateCallback");window.addEventListener("load",()=>window.setTimeout(r,100)),window.addEventListener("vscode.markdown.updateContent",r),r()}d(b,"preview");const g=d(u=>{u.querySelectorAll("[is]").forEach(c=>{if(c.nodeName.includes("-")||document.createElement(c.nodeName).constructor!==c.constructor)return;const{outerHTML:m}=c;c.outerHTML=m,console.debug("[marp-vscode] Custom element has been upgraded forcibly:",m.slice(0,m.indexOf(">")+1||void 0))})},"forceUpgradeCustomElements"),x=d(()=>{const u=document.querySelectorAll("style:not(#__marp-vscode-style,#_defaultStyles,[data-marp-vscode-body])"),c=document.querySelectorAll('link[rel="stylesheet"][href]:not([href*="marp-vscode"])');u.forEach(r=>{r.closest("#__marp-vscode")||(r.dataset.marpVscodeBody=r.textContent??"",r.textContent="")}),c.forEach(r=>{if(r.closest("#__marp-vscode"))return;const{href:m}=r;r.dataset.marpVscodeHref=m,r.removeAttribute("href")})},"removeStyles"),k=d(()=>{const u=document.querySelectorAll("style[data-marp-vscode-body]"),c=document.querySelectorAll("link[data-marp-vscode-href]");u.forEach(r=>{r.textContent=r.dataset.marpVscodeBody||"",delete r.dataset.marpVscodeBody}),c.forEach(r=>{r.href=r.dataset.marpVscodeHref||"",delete r.dataset.marpVscodeHref})},"restoreStyles");b()})()})();})();

</script>

        </body>
        </html>